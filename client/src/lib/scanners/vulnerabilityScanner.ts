/**
 * Vulnerability Scanner Module
 * 
 * Performs safe, non-intrusive vulnerability checks:
 * - Common security misconfigurations
 * - Exposed sensitive files
 * - Cookie security
 * - CORS configuration
 * - Directory listing
 */

import * as https from 'https';
import * as http from 'http';
import { URL } from 'url';
import type { VulnerabilityScanResult, Severity } from './types';

// Browser-like headers to avoid WAF blocks
const BROWSER_HEADERS = {
  'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
  'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
  'Accept-Language': 'en-US,en;q=0.9',
  'Cache-Control': 'no-cache',
  'Sec-Fetch-Dest': 'document',
  'Sec-Fetch-Mode': 'navigate',
};

// Sensitive paths to check
const SENSITIVE_PATHS = [
  { path: '/.env', name: 'Environment File', severity: 'critical' as Severity },
  { path: '/.git/config', name: 'Git Repository', severity: 'critical' as Severity },
  { path: '/.svn/entries', name: 'SVN Repository', severity: 'critical' as Severity },
  { path: '/wp-config.php.bak', name: 'WordPress Config Backup', severity: 'critical' as Severity },
  { path: '/config.php.bak', name: 'Config File Backup', severity: 'critical' as Severity },
  { path: '/backup.sql', name: 'Database Backup', severity: 'critical' as Severity },
  { path: '/database.sql', name: 'Database Export', severity: 'critical' as Severity },
  { path: '/.DS_Store', name: 'macOS Directory File', severity: 'medium' as Severity },
  { path: '/phpinfo.php', name: 'PHP Info Page', severity: 'high' as Severity },
  { path: '/server-status', name: 'Server Status Page', severity: 'medium' as Severity },
  { path: '/.htaccess', name: 'Apache Config', severity: 'medium' as Severity },
  { path: '/web.config', name: 'IIS Config', severity: 'medium' as Severity },
  { path: '/crossdomain.xml', name: 'Flash Crossdomain Policy', severity: 'low' as Severity },
  { path: '/clientaccesspolicy.xml', name: 'Silverlight Policy', severity: 'low' as Severity },
  { path: '/elmah.axd', name: 'ELMAH Error Log', severity: 'high' as Severity },
  { path: '/trace.axd', name: 'ASP.NET Trace', severity: 'high' as Severity },
  { path: '/.well-known/security.txt', name: 'Security Policy', severity: 'info' as Severity },
  { path: '/robots.txt', name: 'Robots.txt', severity: 'info' as Severity },
  { path: '/sitemap.xml', name: 'Sitemap', severity: 'info' as Severity },
];

// Directory listing indicators
const DIRECTORY_LISTING_PATTERNS = [
  'Index of /',
  'Directory listing',
  '<title>Index of',
  'Parent Directory',
  '[To Parent Directory]',
];

// Common test directories
const TEST_DIRECTORIES = [
  '/admin/',
  '/backup/',
  '/test/',
  '/temp/',
  '/tmp/',
  '/logs/',
  '/debug/',
];

/**
 * Scan for vulnerabilities
 */
export async function scanVulnerabilities(
  url: string,
  timeout: number = 10000
): Promise<VulnerabilityScanResult[]> {
  const results: VulnerabilityScanResult[] = [];
  const parsedUrl = new URL(url);
  const baseUrl = `${parsedUrl.protocol}//${parsedUrl.hostname}`;

  // Check for sensitive files (parallel execution)
  const sensitiveFileChecks = SENSITIVE_PATHS.map(async (item) => {
    const found = await checkPathExists(baseUrl + item.path, timeout);
    if (found.exists) {
      return {
        type: 'Exposed Sensitive File',
        category: 'Information Disclosure',
        found: true,
        severity: item.severity,
        details: `${item.name} found at ${item.path}`,
        evidence: found.evidence,
        recommendation: `Remove or restrict access to ${item.path}`,
        cwe: 'CWE-538',
        owasp: 'A01:2021 Broken Access Control',
      };
    }
    return null;
  });

  const sensitiveResults = await Promise.all(sensitiveFileChecks);
  results.push(...sensitiveResults.filter(Boolean) as VulnerabilityScanResult[]);

  // Check for directory listing
  const dirListingChecks = TEST_DIRECTORIES.map(async (dir) => {
    const hasListing = await checkDirectoryListing(baseUrl + dir, timeout);
    if (hasListing) {
      return {
        type: 'Directory Listing Enabled',
        category: 'Information Disclosure',
        found: true,
        severity: 'medium' as Severity,
        details: `Directory listing enabled at ${dir}`,
        recommendation: 'Disable directory listing in web server configuration',
        cwe: 'CWE-548',
        owasp: 'A01:2021 Broken Access Control',
      };
    }
    return null;
  });

  const dirResults = await Promise.all(dirListingChecks);
  results.push(...dirResults.filter(Boolean) as VulnerabilityScanResult[]);

  // Check cookies
  const cookieVulns = await checkCookieSecurity(url, timeout);
  results.push(...cookieVulns);

  // Check CORS
  const corsVulns = await checkCORS(url, timeout);
  results.push(...corsVulns);

  // Check for missing security measures
  const securityChecks = await checkSecurityMeasures(url, timeout);
  results.push(...securityChecks);

  return results;
}

/**
 * Check if a path exists and potentially returns sensitive data
 */
async function checkPathExists(
  url: string,
  timeout: number
): Promise<{ exists: boolean; evidence?: string }> {
  return new Promise((resolve) => {
    const parsedUrl = new URL(url);
    const protocol = parsedUrl.protocol === 'https:' ? https : http;

    const options: http.RequestOptions = {
      hostname: parsedUrl.hostname,
      port: parsedUrl.port || (parsedUrl.protocol === 'https:' ? 443 : 80),
      path: parsedUrl.pathname,
      method: 'GET',
      timeout: timeout,
      headers: BROWSER_HEADERS,
    };

    if (parsedUrl.protocol === 'https:') {
      (options as https.RequestOptions).rejectUnauthorized = false;
    }

    const req = protocol.request(options, (res) => {
      let body = '';
      
      res.on('data', (chunk) => {
        body += chunk.toString();
        // Limit response size
        if (body.length > 5000) {
          req.destroy();
        }
      });

      res.on('end', () => {
        // Check if it's a valid response (not 404, 403, etc.)
        if (res.statusCode === 200) {
          // Check if it's not a default error page
          const lowerBody = body.toLowerCase();
          const isRealContent = !lowerBody.includes('not found') &&
                               !lowerBody.includes('404') &&
                               !lowerBody.includes('forbidden') &&
                               body.length > 10;
          
          resolve({
            exists: isRealContent,
            evidence: isRealContent ? `Status: ${res.statusCode}, Size: ${body.length} bytes` : undefined,
          });
        } else {
          resolve({ exists: false });
        }
      });
    });

    req.on('error', () => resolve({ exists: false }));
    req.on('timeout', () => {
      req.destroy();
      resolve({ exists: false });
    });

    req.end();
  });
}

/**
 * Check for directory listing
 */
async function checkDirectoryListing(
  url: string,
  timeout: number
): Promise<boolean> {
  return new Promise((resolve) => {
    const parsedUrl = new URL(url);
    const protocol = parsedUrl.protocol === 'https:' ? https : http;

    const options: http.RequestOptions = {
      hostname: parsedUrl.hostname,
      port: parsedUrl.port || (parsedUrl.protocol === 'https:' ? 443 : 80),
      path: parsedUrl.pathname,
      method: 'GET',
      timeout: timeout,
      headers: BROWSER_HEADERS,
    };

    if (parsedUrl.protocol === 'https:') {
      (options as https.RequestOptions).rejectUnauthorized = false;
    }

    const req = protocol.request(options, (res) => {
      let body = '';
      
      res.on('data', (chunk) => {
        body += chunk.toString();
        if (body.length > 10000) {
          req.destroy();
        }
      });

      res.on('end', () => {
        const hasListing = DIRECTORY_LISTING_PATTERNS.some(pattern => 
          body.includes(pattern)
        );
        resolve(hasListing && res.statusCode === 200);
      });
    });

    req.on('error', () => resolve(false));
    req.on('timeout', () => {
      req.destroy();
      resolve(false);
    });

    req.end();
  });
}

/**
 * Check cookie security settings
 */
async function checkCookieSecurity(
  url: string,
  timeout: number
): Promise<VulnerabilityScanResult[]> {
  const results: VulnerabilityScanResult[] = [];

  return new Promise((resolve) => {
    const parsedUrl = new URL(url);
    const protocol = parsedUrl.protocol === 'https:' ? https : http;

    const options: http.RequestOptions = {
      hostname: parsedUrl.hostname,
      port: parsedUrl.port || (parsedUrl.protocol === 'https:' ? 443 : 80),
      path: parsedUrl.pathname,
      method: 'GET',
      timeout: timeout,
      headers: BROWSER_HEADERS,
    };

    if (parsedUrl.protocol === 'https:') {
      (options as https.RequestOptions).rejectUnauthorized = false;
    }

    const req = protocol.request(options, (res) => {
      const cookies = res.headers['set-cookie'] || [];

      for (const cookie of cookies) {
        const cookieLower = cookie.toLowerCase();
        const cookieName = cookie.split('=')[0];

        // Check for missing Secure flag on HTTPS
        if (parsedUrl.protocol === 'https:' && !cookieLower.includes('secure')) {
          results.push({
            type: 'Insecure Cookie',
            category: 'Cookie Security',
            found: true,
            severity: 'medium',
            details: `Cookie "${cookieName}" is missing the Secure flag`,
            recommendation: 'Add Secure flag to all cookies on HTTPS sites',
            cwe: 'CWE-614',
            owasp: 'A05:2021 Security Misconfiguration',
          });
        }

        // Check for missing HttpOnly flag (for session cookies)
        if (!cookieLower.includes('httponly') && 
            (cookieLower.includes('session') || cookieLower.includes('auth'))) {
          results.push({
            type: 'Cookie Missing HttpOnly',
            category: 'Cookie Security',
            found: true,
            severity: 'medium',
            details: `Cookie "${cookieName}" is missing the HttpOnly flag`,
            recommendation: 'Add HttpOnly flag to prevent XSS cookie theft',
            cwe: 'CWE-1004',
            owasp: 'A05:2021 Security Misconfiguration',
          });
        }

        // Check for missing SameSite attribute
        if (!cookieLower.includes('samesite')) {
          results.push({
            type: 'Cookie Missing SameSite',
            category: 'Cookie Security',
            found: true,
            severity: 'low',
            details: `Cookie "${cookieName}" is missing the SameSite attribute`,
            recommendation: 'Add SameSite=Strict or SameSite=Lax to prevent CSRF',
            cwe: 'CWE-1275',
            owasp: 'A05:2021 Security Misconfiguration',
          });
        }
      }

      resolve(results);
    });

    req.on('error', () => resolve(results));
    req.on('timeout', () => {
      req.destroy();
      resolve(results);
    });

    req.end();
  });
}

/**
 * Check CORS configuration
 */
async function checkCORS(
  url: string,
  timeout: number
): Promise<VulnerabilityScanResult[]> {
  const results: VulnerabilityScanResult[] = [];

  return new Promise((resolve) => {
    const parsedUrl = new URL(url);
    const protocol = parsedUrl.protocol === 'https:' ? https : http;

    const options: http.RequestOptions = {
      hostname: parsedUrl.hostname,
      port: parsedUrl.port || (parsedUrl.protocol === 'https:' ? 443 : 80),
      path: parsedUrl.pathname,
      method: 'OPTIONS',
      timeout: timeout,
      headers: {
        ...BROWSER_HEADERS,
        'Origin': 'https://evil.example.com',
        'Access-Control-Request-Method': 'GET',
      },
    };

    if (parsedUrl.protocol === 'https:') {
      (options as https.RequestOptions).rejectUnauthorized = false;
    }

    const req = protocol.request(options, (res) => {
      const allowOrigin = res.headers['access-control-allow-origin'];
      const allowCredentials = res.headers['access-control-allow-credentials'];

      if (allowOrigin === '*') {
        results.push({
          type: 'Overly Permissive CORS',
          category: 'CORS Misconfiguration',
          found: true,
          severity: allowCredentials === 'true' ? 'critical' : 'medium',
          details: 'CORS allows any origin (Access-Control-Allow-Origin: *)',
          recommendation: 'Restrict CORS to specific trusted domains',
          cwe: 'CWE-942',
          owasp: 'A05:2021 Security Misconfiguration',
        });
      }

      if (allowOrigin === 'https://evil.example.com') {
        results.push({
          type: 'CORS Reflects Origin',
          category: 'CORS Misconfiguration',
          found: true,
          severity: 'high',
          details: 'CORS reflects any origin without validation',
          recommendation: 'Implement proper origin validation',
          cwe: 'CWE-942',
          owasp: 'A05:2021 Security Misconfiguration',
        });
      }

      resolve(results);
    });

    req.on('error', () => resolve(results));
    req.on('timeout', () => {
      req.destroy();
      resolve(results);
    });

    req.end();
  });
}

/**
 * Check for missing security measures
 */
async function checkSecurityMeasures(
  url: string,
  timeout: number
): Promise<VulnerabilityScanResult[]> {
  const results: VulnerabilityScanResult[] = [];

  return new Promise((resolve) => {
    const parsedUrl = new URL(url);
    const protocol = parsedUrl.protocol === 'https:' ? https : http;

    const options: http.RequestOptions = {
      hostname: parsedUrl.hostname,
      port: parsedUrl.port || (parsedUrl.protocol === 'https:' ? 443 : 80),
      path: parsedUrl.pathname,
      method: 'GET',
      timeout: timeout,
      headers: BROWSER_HEADERS,
    };

    if (parsedUrl.protocol === 'https:') {
      (options as https.RequestOptions).rejectUnauthorized = false;
    }

    const req = protocol.request(options, (res) => {
      // Check for server version disclosure
      const server = res.headers['server'];
      if (server && /\d+\.\d+/.test(server)) {
        results.push({
          type: 'Server Version Disclosure',
          category: 'Information Disclosure',
          found: true,
          severity: 'low',
          details: `Server header exposes version: ${server}`,
          evidence: server,
          recommendation: 'Remove or obfuscate server version information',
          cwe: 'CWE-200',
          owasp: 'A05:2021 Security Misconfiguration',
        });
      }

      // Check for X-Powered-By header
      const poweredBy = res.headers['x-powered-by'];
      if (poweredBy) {
        results.push({
          type: 'Technology Disclosure',
          category: 'Information Disclosure',
          found: true,
          severity: 'low',
          details: `X-Powered-By header exposes: ${poweredBy}`,
          evidence: poweredBy,
          recommendation: 'Remove X-Powered-By header',
          cwe: 'CWE-200',
          owasp: 'A05:2021 Security Misconfiguration',
        });
      }

      // Check HTTP to HTTPS redirect
      if (parsedUrl.protocol === 'http:' && res.statusCode !== 301 && res.statusCode !== 302) {
        results.push({
          type: 'Missing HTTPS Redirect',
          category: 'Transport Security',
          found: true,
          severity: 'medium',
          details: 'HTTP requests are not redirected to HTTPS',
          recommendation: 'Implement HTTP to HTTPS redirect',
          cwe: 'CWE-319',
          owasp: 'A02:2021 Cryptographic Failures',
        });
      }

      resolve(results);
    });

    req.on('error', () => resolve(results));
    req.on('timeout', () => {
      req.destroy();
      resolve(results);
    });

    req.end();
  });
}

export default scanVulnerabilities;

